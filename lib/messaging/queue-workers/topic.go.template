package queueworkers

import (
	"time"

	"raidhub/lib/messaging/messages"
	"raidhub/lib/messaging/processing"
	"raidhub/lib/messaging/routing"
	"raidhub/lib/utils/logging"

	amqp "github.com/rabbitmq/amqp091-go"
)

// TEMPLATE LOGGER (copy to your domain package)
// Each domain should have its own singleton logger in lib/{domain}/logger.go:
//
// package {domain}
//
// import (
// 	"log"
// 	"sync"
// )
//
// var (
// 	loggerSingleton Logger
// 	loggerOnce      sync.Once
// )
//
// type Logger interface {
// 	Info(msg string, fields ...any)
// 	Warn(msg string, fields ...any)
// 	Error(msg string, fields ...any)
// 	Debug(msg string, fields ...any)
// }
//
// type defaultLogger struct { prefix string }
//
// func (l *defaultLogger) Info(msg string, fields ...any) {
// 	log.Printf("[%s] INFO: %s %v", l.prefix, msg, fields)
// }
// // ... (Warn, Error, Debug methods)
//
// func getLogger() Logger {
// 	loggerOnce.Do(func() {
// 		loggerSingleton = &defaultLogger{prefix: "{domain}"}
// 	})
// 	return loggerSingleton
// }
//
// func Info(msg string, fields ...any) { getLogger().Info(msg, fields...) }
// func Warn(msg string, fields ...any) { getLogger().Warn(msg, fields...) }
// func Error(msg string, fields ...any) { getLogger().Error(msg, fields...) }
// func Debug(msg string, fields ...any) { getLogger().Debug(msg, fields...) }

// TEMPLATE: Copy this file and modify for your new topic
// Steps:
// 1. Rename this file to your_topic_name.go
// 2. Update the function names and config below
// 3. Add your message type to lib/messaging/messages/ (create a new file)
// 4. Add your queue constant to lib/messaging/routing/constants.go
// 5. Add case to switch statement in apps/hermes/main.go

// YourTopicName creates a new topic for your queue
func YourTopicName() processing.Topic {
	return processing.NewTopic(processing.TopicConfig{
		QueueName:             routing.YourQueueName,        // Add to constants.go
		MinWorkers:            1,                            // Adjust as needed
		MaxWorkers:            10,                           // Adjust as needed
		DesiredWorkers:        2,                            // Adjust as needed
		KeepInReady:           true,                         // Usually true
		PrefetchCount:         1,                            // Usually 1
		ScaleUpThreshold:      100,                          // Default: scale up when queue has 100+ messages
		ScaleDownThreshold:    10,                           // Default: scale down when queue has <10 messages
		ScaleUpPercent:        0.2,                          // Default: add 20% more workers
		ScaleDownPercent:      0.1,                          // Default: remove 10% of workers
		MinWorkersPerStep:     1,                            // Default: always add/remove at least 1 worker
		MaxWorkersPerStep:     10,                           // Default: add/remove at most 10 workers per step
		ConsecutiveChecksUp:   2,                            // Default: require 2 checks before scaling up
		ConsecutiveChecksDown: 3,                            // Default: require 3 checks before scaling down
		ScaleCooldown:         2 * time.Minute,              // Default: don't scale again within 2 minutes
		BungieSystemDeps:      []string{},                   // Optional: Bungie API systems that must be available
		MaxRetryCount:         0,                            // Default: 0 = unlimited retries. Set to limit retries before DLQ
	}, processYourTopicName)
}

// processYourTopicName handles messages for your topic
func processYourTopicName(worker processing.WorkerInterface, message amqp.Delivery) error {
	// Option 1: JSON message (recommended)
	request, err := processing.ParseJSON[messages.YourMessageType](worker, message.Body)
	if err != nil {
		return err // ParseJSON already logs the error
	}
	
	worker.Info("PROCESSING_MESSAGE", map[string]any{
		"id": request.ID, // Adjust field names to match your message type
	})
	
	// Access resources via worker:
	// - worker.Context() for cancellation/timeouts
	// - Use domain services for business logic (e.g., player.Crawl, character.Fill)
	
	// TODO: Implement your business logic here
	// - Call domain service functions
	// - Handle errors appropriately:
	//   - Return error for transient failures (will be retried)
	//   - Return processing.NewUnretryableError(err) for permanent failures (goes to DLQ)
	
	// Example error handling:
	// if err != nil {
	//     worker.Error("OPERATION_FAILED", err, map[string]any{
	//         logging.MEMBERSHIP_ID: request.MembershipId,
	//     })
	//     return err // Transient error - will retry
	//     // OR: return processing.NewUnretryableError(err) // Permanent error - goes to DLQ
	// }
	
	return nil

	// Option 2: Int64 message (for simple ID-based messages) - uncomment to use
	// id, err := processing.ParseInt64(worker, message.Body)
	// if err != nil {
	//     return err
	// }
	// 
	// // TODO: Implement your business logic here
	// 
	// return nil

	// Option 3: Text message - uncomment to use
	// text, err := processing.ParseText(worker, message.Body)
	// if err != nil {
	//     return err
	// }
	// 
	// // TODO: Implement your business logic here
	// 
	// return nil
}
